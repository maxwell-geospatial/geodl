% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predictSpatial.R
\name{predictSpatial}
\alias{predictSpatial}
\title{predictSpatial}
\usage{
predictSpatial(
  imgIn,
  model,
  predOut,
  mode = "multiclass",
  probs = FALSE,
  useCUDA = FALSE,
  nCls,
  chpSize,
  stride_x,
  stride_y,
  crop,
  nChn = 3,
  normalize = FALSE,
  bMns,
  bSDs,
  rescaleFactor = 1
)
}
\arguments{
\item{imgIn}{Input image to classify. Can be a file path (full or relative to
current working directory) or a spatRaster object. Should have the same number
of bands as the data used to train the model. Bands must also be in the same
order.}

\item{model}{Trained model to use to infer to new data.}

\item{predOut}{Name of output prediction with full path or path relative to
the working directory. Must also include the file extension (e.g., ".tif).}

\item{mode}{Either "multiclass" or "binary". Default is "multiclass". If model
returns a single logit for the positive case, sould be "binary". If two or more
class logits are returned, this shoud be "multiclass".}

\item{probs}{TRUE OR FALSE. Whether to generate a "hard" classification or
return probabilities for each class. If TRUE and for a binary classification,
the positive class probability is returned as a single-band raster grid. If
TRUE and for a multiclass classification, all class probabilities are returned as
a multiband raster. Probabilities will sum to 1, ignoring rounding error. If
FALSE, the predicted class index value is returned. This is the class with
the largest predicted logit or softmax/sigmoid probability. Default is FALSE.}

\item{useCUDA}{TRUE or FALSE. Whether or not to perform the inference on a GPU.
If TRUE, the GPU is used. If FALSE, the CPU is used. Must have access to a CUDA-
enabled graphics card. Default is FALSE. Note that using a GPU significantly
speeds up inference.}

\item{nCls}{Number of classes being differentiated. Should be 1 for a binary
classification problem and the number of classes for a multiclass classification
problem.}

\item{chpSize}{Size of image chips that will be fed through the prediction process.
We recommend using the size of the image chips used to train the model. However,
this is not strictly necessary.}

\item{stride_x}{Stride in the x direction. We recommend using a 50\% overlap.}

\item{stride_y}{Stride in the y direction. We recommend using a 50\% overlap.}

\item{crop}{Number of rows and columns to crop from each side of the image chip
to reduce edge effects. We recommend at least 20.}

\item{nChn}{Number of input channels. Default is 3.}

\item{normalize}{TRUE or FALSE. Whether to apply normalization. If FALSE,
bMns and bSDs is ignored. Default is FALSE. If TRUE, you must provide bMns
and bSDs. This should match the setting used in defineSegDataSet().}

\item{bMns}{Vector of band means. Length should be the same as the number of bands.
Normalization is applied before any rescaling within the function. This should
match the setting used in defineSegDataSet().}

\item{bSDs}{Vector of band standard deviations. Length should be the same
as the number of bands. Normalization is applied before any rescaling within
the function. This should match the setting used in defineSegDataSet().}

\item{rescaleFactor}{A rescaling factor to rescale the bands to 0 to 1. For
example, this could be set to 255 to rescale 8-bit data. Default is 1 or no
rescaling. This should match the setting used in defineSegDataSet().}
}
\value{
A spatRast object and a raster grid saved to disk of either predicted
class indices or predicted class probabilities.
}
\description{
Apply a trained semantic segmentation model to predict back to geospatial raster data
}
\details{
This function generates a pixel-by-pixel prediction using input data and a
trained semantic segmentation model. Can return either hard classifications or
class probabilities. Result is written to disk and provided as a spatRaster object.
}
